<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>roles/roles_common.js - The meteor-roles API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="The meteor-roles API" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: v1.2.14</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Roles.html">Roles</a></li>
                                <li><a href="../classes/UIHelpers.html">UIHelpers</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/Roles.html">Roles</a></li>
                                <li><a href="../modules/UIHelpers.html">UIHelpers</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: roles/roles_common.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
;(function () {

/**
 * Provides functions related to user authorization. Compatible with built-in Meteor accounts packages.
 *
 * It uses &#x60;roles&#x60; field to &#x60;Meteor.users&#x60; documents which is an array of subdocuments with the following
 * schema:
 *  - &#x60;_id&#x60;: role name
 *  - &#x60;partition&#x60;: partition name
 *  - &#x60;assigned&#x60;: boolean, if the role was manually assigned (set), or was automatically inferred (eg., subroles)
 *
 * Roles themselves are accessible throgh &#x60;Meteor.roles&#x60; collection and documents consist of:
 *  - &#x60;_id&#x60;: role name
 *  - &#x60;children&#x60;: list of subdocuments:
 *    - &#x60;_id&#x60;
 *
 * Children list elements are subdocuments so that they can be easier extended in the future or by plugins.
 *
 * Roles can have multiple parents and can be children (subroles) of multiple roles.
 *
 * Example: &#x60;{_id: &quot;admin&quot;, children: [{_id: &quot;editor&quot;}]}&#x60;
 *
 * @module Roles
 */
 if (!Meteor.roles) {
  Meteor.roles = new Mongo.Collection(&quot;roles&quot;);
}

/**
 * @class Roles
 */
if (&#x27;undefined&#x27; === typeof Roles) {
  Roles = {};
}

&quot;use strict&quot;;

var getGroupsForUserDeprecationWarning = false;

_.extend(Roles, {

  /**
   * Used as a global group (now partition) name. Not used anymore.
   *
   * @property GLOBAL_GROUP
   * @static
   * @deprecated
   */
  GLOBAL_GROUP: null,

  /**
   * Create a new role.
   *
   * @method createRole
   * @param {String} roleName Name of role.
   * @param {Object} [options] Options:
   *   - &#x60;unlessExists&#x60;: if &#x60;true&#x60;, exception will not be thrown in the role already exists
   * @return {String} ID of the new role.
   * @static
   */
  createRole: function (roleName, options) {
    var match;

    options = options || {};

    Roles._checkRoleName(roleName);

    options = _.defaults(options, {
      unlessExists: false
    });

    try {
      return Meteor.roles.insert({_id: roleName, children: []});
    } catch (e) {
      // (from Meteor accounts-base package, insertUserDoc func)
      // XXX string parsing sucks, maybe
      // https://jira.mongodb.org/browse/SERVER-3069 will get fixed one day
      if (e.name !== &#x27;MongoError&#x27;) throw e;
      match = e.err.match(/E11000 duplicate key error index: ([^ ]+)/);
      if (!match) throw e;
      if (match[1].indexOf(&#x27;$_id&#x27;) !== -1) {
        if (options.unlessExists) return null;
        throw new Error(&quot;Role &#x27;&quot; + roleName + &quot;&#x27; already exists.&quot;);
      }
      throw e;
    }
  },

  /**
   * Delete an existing role.
   *
   * If the role is set for any user, it is automatically unset.
   *
   * @method deleteRole
   * @param {String} roleName Name of role.
   * @static
   */
  deleteRole: function (roleName) {
    var roles;

    Roles._checkRoleName(roleName);

    // we first remove the role as a children, otherwise
    // Roles._assureConsistency might re-add the role
    Meteor.roles.update({}, {
      $pull: {
        children: {
          _id: roleName
        }
      }
    }, {multi: true});

    Roles.getUsersInRole(roleName, {
      anyPartition: true,
      queryOptions: {
        fields: {
          _id: 1,
          roles: 1
        }
      }
    }).forEach(function (user, index, cursor) {
      // role can be assigned multiple times to the user, for multiple partitions
      // we have to remove the role for each of those partitions
      roles = _.filter(user.roles, Roles._roleMatcher(roleName));
      _.each(roles, function (role) {
        Roles._removeUserFromRole(user, roleName, {
          partition: role.partition,
          // we want to remove the role in any case
          _assigned: null
        });
      });

      // handle the edge case
      Roles._assureConsistency(user);
    });

    // remove the role itself
    Meteor.roles.remove({_id: roleName});
  },

  /**
   * Add role parent to the role.
   *
   * Previous parents are kept (role can have multiple parents). For users which have the
   * parent role set, new subroles are added automatically.
   *
   * @method addRoleParent
   * @param {String} roleName Name of role.
   * @param {String} parentName Name of parent role.
   * @static
   */
  addRoleParent: function (roleName, parentName) {
    var role,
        count,
        parentRoles,
        rolesToCheck,
        alreadyCheckedRoles,
        checkRoleName,
        checkRole;

    Roles._checkRoleName(roleName);
    Roles._checkRoleName(parentName);

    // query to get role&#x27;s children
    role = Meteor.roles.findOne({_id: roleName});

    if (!role) {
      throw new Error(&quot;Role &#x27;&quot; + roleName + &quot;&#x27; does not exist.&quot;);
    }

    // detect cycles
    alreadyCheckedRoles = [];
    rolesToCheck = _.pluck(role.children, &#x27;_id&#x27;);
    while (rolesToCheck.length) {
      checkRoleName = rolesToCheck.pop();
      if (checkRoleName === parentName) {
        throw new Error(&quot;Roles &#x27;&quot; + roleName + &quot;&#x27; and &#x27;&quot; + parentName + &quot;&#x27; would form a cycle.&quot;);
      }
      alreadyCheckedRoles.push(checkRoleName);

      checkRole = Meteor.roles.findOne({_id: checkRoleName});

      // This should not happen, but this is a problem to address at some other time.
      if (!checkRole) continue;

      rolesToCheck = _.union(rolesToCheck, _.difference(_.pluck(checkRole.children, &#x27;_id&#x27;), alreadyCheckedRoles));
    }

    count = Meteor.roles.update({
      _id: parentName,
      &#x27;children._id&#x27;: {
        $ne: role._id
      }
    }, {
      $addToSet: {
        children: {
          _id: role._id
        }
      }
    });

    // if there was no change, parent role might not exist, or role is
    // already a subrole; in any case we do not have anything more to do
    if (!count) return;

    Roles.getUsersInRole(parentName, {
      anyPartition: true,
      queryOptions: {
        fields: {
          _id: 1,
          roles: 1
        }
      }
    }).forEach(function (user, index, cursor) {
      // parent role can be assigned multiple times to the user, for multiple partitions
      // we have to assign a new subrole for each of those partitions
      parentRoles = _.filter(user.roles, Roles._roleMatcher(parentName));
      _.each(parentRoles, function (parentRole) {
        Roles._addUserToRole(user, roleName, {
          partition: parentRole.partition,
          // we are assigning a subrole, so we set it as unassigned,
          // but only if they do not already exist
          _assigned: null
        });
      });
    });
  },

  /**
   * Remove role parent from the role.
   *
   * Other parents are kept (role can have multiple parents). For users which have the
   * parent role set, removed subrole is removed automatically.
   *
   * @method removeRoleParent
   * @param {String} roleName Name of role.
   * @param {String} parentName Name of parent role.
   * @static
   */
  removeRoleParent: function (roleName, parentName) {
    var role,
        count,
        parentRoles;

    Roles._checkRoleName(roleName);
    Roles._checkRoleName(parentName);

    // check for role existence
    // this would not really be needed, but we are trying to match addRoleParent
    role = Meteor.roles.findOne({_id: roleName}, {fields: {_id: 1}});

    if (!role) {
      throw new Error(&quot;Role &#x27;&quot; + roleName + &quot;&#x27; does not exist.&quot;);
    }

    count = Meteor.roles.update({
      _id: parentName
    }, {
      $pull: {
        children: {
          _id: role._id
        }
      }
    });

    // if there was no change, parent role might not exist, or role was
    // already not a subrole; in any case we do not have anything more to do
    if (!count) return;

    Roles.getUsersInRole(parentName, {
      anyPartition: true,
      queryOptions: {
        fields: {
          _id: 1,
          roles: 1
        }
      }
    }).forEach(function (user, index, cursor) {
      // parent role can be assigned multiple times to the user, for multiple partitions
      // we have to remove the subrole for each of those partitions
      parentRoles = _.filter(user.roles, Roles._roleMatcher(parentName));
      _.each(parentRoles, function (parentRole) {
        Roles._removeUserFromRole(user, roleName, {
          partition: parentRole.partition,
          // but we want to remove it only if it was not also explicitly assigned
          _assigned: false
        });
      });

      // handle the edge case
      Roles._assureConsistency(user);
    });
  },

  /**
   * Add users to roles.
   *
   * Adds roles to existing roles for each user.
   *
   * @example
   *     Roles.addUsersToRoles(userId, &#x27;admin&#x27;)
   *     Roles.addUsersToRoles(userId, [&#x27;view-secrets&#x27;], &#x27;example.com&#x27;)
   *     Roles.addUsersToRoles([user1, user2], [&#x27;user&#x27;,&#x27;editor&#x27;])
   *     Roles.addUsersToRoles([user1, user2], [&#x27;glorious-admin&#x27;, &#x27;perform-action&#x27;], &#x27;example.org&#x27;)
   *
   * @method addUsersToRoles
   * @param {Array|String} users User ID(s) or object(s) with an &#x60;_id&#x60; field.
   * @param {Array|String} roles Name(s) of roles to add users to. Roles have to exist.
   * @param {Object|String} [options] Options:
   *   - &#x60;partition&#x60;: name of the partition, or &#x60;null&#x60; for the global role
   *   - &#x60;ifExists&#x60;: if &#x60;true&#x60;, do not throw an exception if the role does not exist
   *
   * Alternatively, it can be a partition name string.
   * @static
   */
  addUsersToRoles: function (users, roles, options) {
    if (!users) throw new Error (&quot;Missing &#x27;users&#x27; param.&quot;);
    if (!roles) throw new Error (&quot;Missing &#x27;roles&#x27; param.&quot;);

    options = options || {};

    // ensure arrays
    if (!_.isArray(users)) users = [users];
    if (!_.isArray(roles)) roles = [roles];

    if (_.isString(options)) {
      options = {partition: options};
    }

    options.partition = options.partition || null;

    Roles._checkPartitionName(options.partition);

    options = _.defaults(options, {
      ifExists: false,
      // internal option, should not be used publicly because it will break assumptions
      // in te code; publicly, you can only add users to an assigned role
      // should the role be set as assigned, default is &#x60;true&#x60;; &#x60;null&#x60; is the same as &#x60;false&#x60;,
      // only that it does not force the value to &#x60;false&#x60; if the role is already assigned
      _assigned: true
    });

    _.each(users, function (user) {
      _.each(roles, function (role) {
        Roles._addUserToRole(user, role, options);
      });
    });
  },

  /**
   * Set users&#x27; roles.
   *
   * Replaces all existing roles with a new set of roles.
   *
   * @example
   *     Roles.setUserRoles(userId, &#x27;admin&#x27;)
   *     Roles.setUserRoles(userId, [&#x27;view-secrets&#x27;], &#x27;example.com&#x27;)
   *     Roles.setUserRoles([user1, user2], [&#x27;user&#x27;,&#x27;editor&#x27;])
   *     Roles.setUserRoles([user1, user2], [&#x27;glorious-admin&#x27;, &#x27;perform-action&#x27;], &#x27;example.org&#x27;)
   *
   * @method setUserRoles
   * @param {Array|String} users User ID(s) or object(s) with an &#x60;_id&#x60; field.
   * @param {Array|String} roles Name(s) of roles to add users to. Roles have to exist.
   * @param {Object|String} [options] Options:
   *   - &#x60;partition&#x60;: name of the partition, or &#x60;null&#x60; for the global role
   *   - &#x60;ifExists&#x60;: if &#x60;true&#x60;, do not throw an exception if the role does not exist
   *
   * Alternatively, it can be a partition name string.
   * @static
   */
  setUserRoles: function (users, roles, options) {
    var id;

    if (!users) throw new Error (&quot;Missing &#x27;users&#x27; param.&quot;);
    if (!roles) throw new Error (&quot;Missing &#x27;roles&#x27; param.&quot;);

    options = options || {};

    // ensure arrays
    if (!_.isArray(users)) users = [users];
    if (!_.isArray(roles)) roles = [roles];

    if (_.isString(options)) {
      options = {partition: options};
    }

    options.partition = options.partition || null;

    Roles._checkPartitionName(options.partition);

    options = _.defaults(options, {
      ifExists: false,
      // internal option, should not be used publicly because it will break assumptions
      // in te code; publicly, you can only add users to an assigned role
      // should the role be set as assigned, default is &#x60;true&#x60;; &#x60;null&#x60; is the same as &#x60;false&#x60;,
      // only that it does not force the value to &#x60;false&#x60; if the role is already assigned
      _assigned: true
    });

    _.each(users, function (user) {
      if (_.isObject(user)) {
        id = user._id;
      }
      else {
        id = user;
      }
      // we first clear all roles for the user
      Meteor.users.update(id, {$pull: {roles: {partition: options.partition}}});

      // and then add all
      _.each(roles, function (role) {
        Roles._addUserToRole(user, role, options);
      });
    });
  },

  /**
   * Add one user to one role.
   *
   * @method _addUserToRole
   * @param {String|Object} user User ID or object with an &#x60;_id&#x60; field.
   * @param {String} roleName Name of the role to add the user to. The role have to exist.
   * @param {Object} options Options:
   *   - &#x60;partition&#x60;: name of the partition, or &#x60;null&#x60; for the global role
   *   - &#x60;ifExists&#x60;: if &#x60;true&#x60;, do not throw an exception if the role does not exist
   *   - &#x60;_assigned&#x60;: internal option, should not be used publicly because it will break assumptions
   *     in te code; publicly, you can only add users to an assigned role
   *     should the role be set as assigned (&#x60;true&#x60;), &#x60;null&#x60; is the same as &#x60;false&#x60;,
   *     only that it does not force the value to &#x60;false&#x60; if the role is already assigned
   * @return {Array} Roles set during the call (even those already set).
   * @private
   * @static
   */
  _addUserToRole: function (user, roleName, options) {
    var id,
        role,
        count,
        setRoles;

    Roles._checkRoleName(roleName);
    Roles._checkPartitionName(options.partition);

    if (_.isObject(user)) {
      id = user._id;
    }
    else {
      id = user;
    }

    if (!id) return [];

    role = Meteor.roles.findOne({_id: roleName}, {fields: {children: 1}});

    if (!role) {
      if (options.ifExists) {
        return [];
      }
      else {
        throw new Error(&quot;Role &#x27;&quot; + roleName + &quot;&#x27; does not exist.&quot;);
      }
    }

    // add new role if it is not already added
    count = Meteor.users.update({
      _id: id,
      roles: {
        $not: {
          $elemMatch: {
            _id: roleName,
            partition: options.partition
          }
        }
      }

    }, {
      $addToSet: {
        roles: {
          _id: roleName,
          partition: options.partition,
          // we want to make sure it is a boolean value
          assigned: !!options._assigned
        }
      }
    });

    if (!count) {
      // a role has not been added, it maybe already exists
      if (options._assigned) {
        // let&#x27;s make sure it is set as assigned
        Meteor.users.update({
          _id: id,
          roles: {
            $elemMatch: {
              _id: roleName,
              partition: options.partition
            }
          }

        }, {
          $set: {
            &#x27;roles.$.assigned&#x27;: true
          }
        });
      }
      else if (options._assigned === false) {
        // let&#x27;s make sure it is set as unassigned
        Meteor.users.update({
          _id: id,
          roles: {
            $elemMatch: {
              _id: roleName,
              partition: options.partition
            }
          }

        }, {
          $set: {
            &#x27;roles.$.assigned&#x27;: false
          }
        });
      }
    }

    setRoles = [{
      _id: roleName,
      partition: options.partition
    }];

    _.each(role.children, function (child) {
      // subroles are set as unassigned, but only if they do not already exist
      setRoles = setRoles.concat(Roles._addUserToRole(user, child._id, _.extend({}, options, {_assigned: null})));
    });

    return setRoles;
  },

  /**
   * Remove users from assigned roles.
   *
   * @example
   *     Roles.removeUsersFromRoles(userId, &#x27;admin&#x27;)
   *     Roles.removeUsersFromRoles([userId, user2], [&#x27;editor&#x27;])
   *     Roles.removeUsersFromRoles(userId, [&#x27;user&#x27;], &#x27;group1&#x27;)
   *
   * @method removeUsersFromRoles
   * @param {Array|String} users User ID(s) or object(s) with an &#x60;_id&#x60; field.
   * @param {Array|String} roles Name(s) of roles to add users to. Roles have to exist.
   * @param {Object|String} [options] Options:
   *   - &#x60;partition&#x60;: name of the partition, or &#x60;null&#x60; for the global role
   *
   * Alternatively, it can be a partition name string.
   * @static
   */
  removeUsersFromRoles: function (users, roles, options) {
    if (!users) throw new Error (&quot;Missing &#x27;users&#x27; param.&quot;);
    if (!roles) throw new Error (&quot;Missing &#x27;roles&#x27; param.&quot;);

    options = options || {};

    // ensure arrays
    if (!_.isArray(users)) users = [users];
    if (!_.isArray(roles)) roles = [roles];

    if (_.isString(options)) {
      options = {partition: options};
    }

    options.partition = options.partition || null;

    Roles._checkPartitionName(options.partition);

    options = _.defaults(options, {
      // internal option, should not be used publicly because it will break assumptions
      // in te code; publicly, you can only remove users from an assigned role
      // when should the role be removed, default is &#x60;true&#x60; which means only when it is assigned,
      // &#x60;false&#x60; means when it is not assigned, and &#x60;null&#x60; means always
      _assigned: true
    });

    _.each(users, function (user) {
      _.each(roles, function (role) {
        Roles._removeUserFromRole(user, role, options);
      });

      // handle the edge case
      Roles._assureConsistency(user);
    });
  },

  /**
   * Remove one user from one role.
   *
   * WARNING: It leaves user&#x27;s roles in a possibly inconsistent state. Because we allow the same
   * role to be a child of multiple roles it might happen that it removes some subroles which
   * it should not because they are in effect also through some other parent role. You should always
   * call &#x60;_assureConsistency&#x60; after you are finished with calls to &#x60;_removeUserFromRole&#x60; for a
   * particular user.
   *
   * @method _removeUserFromRole
   * @param {String|Object} user User ID or object with an &#x60;_id&#x60; field.
   * @param {String} roleName Name of the role to add the user to. The role have to exist.
   * @param {Object} options Options:
   *   - &#x60;partition&#x60;: name of the partition, or &#x60;null&#x60; for the global role
   *   - &#x60;_assigned&#x60;: internal option, should not be used publicly because it will break assumptions
   *     in te code; publicly, you can only remove users from an assigned role
   *     if &#x60;true&#x60;, only manually assigned roles are removed, if &#x60;false&#x60;, only automatically
   *     assigned roles are removed, if &#x60;null&#x60;, any role is removed
   * @private
   * @static
   */
  _removeUserFromRole: function (user, roleName, options) {
    var id,
        role,
        update;

    Roles._checkRoleName(roleName);
    Roles._checkPartitionName(options.partition);

    if (_.isObject(user)) {
      id = user._id;
    }
    else {
      id = user;
    }

    if (!id) return;

    update = {
      $pull: {
        roles: {
          _id: roleName,
          partition: options.partition
        }
      }
    };

    if (options._assigned) {
      update.$pull.roles.assigned = true;
    }
    else if (options._assigned === false) {
      update.$pull.roles.assigned = false;
    }

    // we try to remove the role in every case, whether the role really exists or not
    Meteor.users.update(id, update);

    role = Meteor.roles.findOne({_id: roleName}, {fields: {children: 1}});

    // role does not exist, we do not anything more
    if (!role) return;

    _.each(role.children, function (child) {
      // if a child role has been assigned explicitly, we do not remove it
      Roles._removeUserFromRole(user, child._id, _.extend({}, options, {_assigned: false}));
    });
  },

  /**
   * Makes sure all subroles are correctly set, and no extra subroles are set which should not be.
   *
   * Used internally after complicated changes, but it can also be used whenever one feels that
   * there might be inconsistencies (eg., after a crash).
   *
   * We simply re-set to the user their assigned roles again and remove any roles which
   * are marked as not explicitly assigned, and have not been part of what we currently set.
   *
   * @method _assureConsistency
   * @param {String|Object} user User ID or an actual user object.
   * @private
   * @static
   */
  _assureConsistency: function (user) {
    var roles,
        setRoles;

    // we want always the latest state
    user = Roles._resolveUser(user, true);

    // only assigned roles
    roles = _.filter(user.roles, Roles._onlyAssignedMatcher());

    setRoles = [];
    _.each(roles, function (role) {
      setRoles = setRoles.concat(Roles._addUserToRole(user, role._id, {
        partition: role.partition,
        _assigned: role.assigned, // this is true
        ifExists: true
      }));
    });

    if (setRoles.length) {
      // remove all extra entries which should not be there
      Meteor.users.update(user._id, {
        $pull: {
          roles: {
            $nor: _.map(setRoles, function (role) {return _.pick(role, &#x27;_id&#x27;, &#x27;partition&#x27;)})
          }
        }
      });
    }
    else {
      Meteor.users.update(user._id, {$set: {roles: []}});
    }
  },

  /**
   * Check if user has specified roles.
   *
   * @example
   *     // global roles
   *     Roles.userIsInRole(user, &#x27;admin&#x27;)
   *     Roles.userIsInRole(user, [&#x27;admin&#x27;,&#x27;editor&#x27;])
   *     Roles.userIsInRole(userId, &#x27;admin&#x27;)
   *     Roles.userIsInRole(userId, [&#x27;admin&#x27;,&#x27;editor&#x27;])
   *
   *     // partition roles (global roles are still checked)
   *     Roles.userIsInRole(user, &#x27;admin&#x27;, &#x27;group1&#x27;)
   *     Roles.userIsInRole(userId, [&#x27;admin&#x27;,&#x27;editor&#x27;], &#x27;group1&#x27;)
   *     Roles.userIsInRole(userId, [&#x27;admin&#x27;,&#x27;editor&#x27;], {partition: &#x27;group1&#x27;})
   *
   * @method userIsInRole
   * @param {String|Object} user User ID or an actual user object.
   * @param {String|Array} roles Name of role or an array of roles to check against. If array,
   *                             will return &#x60;true&#x60; if user is in _any_ role.
   *                             Roles do not have to exist.
   * @param {Object|String} [options] Options:
   *   - &#x60;partition&#x60;: name of the partition; if supplied, limits check to just that partition;
   *     the user&#x27;s global roles will always be checked whether partition is specified or not
   *   - &#x60;anyPartition&#x60;: if set, role can be in any partition (&#x60;partition&#x60; option is ignored)
   *
   * Alternatively, it can be a partition name string.
   * @return {Boolean} &#x60;true&#x60; if user is in _any_ of the target roles
   * @static
   */
  userIsInRole: function (user, roles, options) {
    var id,
        query;

    options = options || {};

    // ensure array to simplify code
    if (!_.isArray(roles)) roles = [roles];

    if (!roles.length) return false;

    if (_.isString(options)) {
      options = {partition: options};
    }

    options.partition = options.partition || null;

    Roles._checkPartitionName(options.partition);

    options = _.defaults(options, {
      anyPartition: false
    });

    if (!user) return false;

    if (_.isObject(user)) {
      if (_.has(user, &#x27;roles&#x27;)) {
        return _.some(roles, function (role) {
          if (options.anyPartition) {
            return _.some(user.roles || [], Roles._roleMatcher(role));
          }
          else {
            return _.some(user.roles || [], Roles._roleAndPartitionMatcher(role, options.partition));
          }
        })
      } else {
        // missing roles field, try going direct via id
        id = user._id;
      }
    } else {
      id = user;
    }

    if (!id) return false;

    if (options.anyPartition) {
      query = {
        _id: id,
        &#x27;roles._id&#x27;: {$in: roles}
      };
    }
    else {
      query = {
        _id: id,
        $or: [{
          roles: {
            $elemMatch: {
              _id: {$in: roles},
              partition: options.partition
            }
          }
        }, {
          roles: {
            $elemMatch: {
              _id: {$in: roles},
              partition: null
            }
          }
        }]
      };
    }

    return !!Meteor.users.findOne(query, {fields: {_id: 1}});
  },

  /**
   * Retrieve user&#x27;s roles.
   *
   * @method getRolesForUser
   * @param {String|Object} user User ID or an actual user object.
   * @param {Object|String} [options] Options:
   *   - &#x60;partition&#x60;: name of partition to provide roles for; if not specified, global roles are returned
   *   - &#x60;anyPartition&#x60;: if set, role can be in any partition (&#x60;partition&#x60; option is ignored)
   *   - &#x60;fullObjects&#x60;: return full roles objects (&#x60;true&#x60;) or just names (&#x60;false&#x60;) (default &#x60;false&#x60;)
   *   - &#x60;onlyAssigned&#x60;: return only assigned roles and not automatically inferred (like subroles)
   *
   * Alternatively, it can be a partition name string.
   * @return {Array} Array of user&#x27;s roles, unsorted.
   * @static
   */
  getRolesForUser: function (user, options) {
    var roles;

    options = options || {};

    if (_.isString(options)) {
      options = {partition: options};
    }

    options.partition = options.partition || null;

    Roles._checkPartitionName(options.partition);

    options = _.defaults(options, {
      fullObjects: false,
      onlyAssigned: false,
      anyPartition: false
    });

    user = Roles._resolveUser(user);

    if (!user) return [];

    if (options.anyPartition) {
      roles = user.roles || [];
    }
    else {
      roles = _.filter(user.roles || [], Roles._partitionMatcher(options.partition));
    }

    if (options.onlyAssigned) {
      roles = _.filter(roles, Roles._onlyAssignedMatcher());
    }

    if (options.fullObjects) {
      return roles;
    }

    return _.uniq(_.pluck(roles, &#x27;_id&#x27;));
  },

  /**
   * Retrieve cursor of all existing roles.
   *
   * @method getAllRoles
   * @param {Object} [queryOptions] Options which are passed directly
   *                                through to &#x60;Meteor.roles.find(query, options)&#x60;.
   * @return {Cursor} Cursor of existing roles.
   * @static
   */
  getAllRoles: function (queryOptions) {
    queryOptions = queryOptions || {sort: {_id: 1}};

    return Meteor.roles.find({}, queryOptions);
  },

  /**
   * Retrieve all users who are in target role.
   *
   * Options:
   *
   * @method getUsersInRole
   * @param {String|Array} roles Name of role or an array of roles. If array, users
   *                             returned will have at least one of the roles
   *                             specified but need not have _all_ roles.
   *                             Roles do not have to exist.
   * @param {Object|String} [options] Options:
   *   - &#x60;partition&#x60;: name of the partition to restrict roles to; user&#x27;s global
   *     roles will also be checked
   *   - &#x60;anyPartition&#x60;: if set, role can be in any partition (&#x60;partition&#x60; option is ignored)
   *   - &#x60;queryOptions&#x60;: options which are passed directly
   *     through to &#x60;Meteor.users.find(query, options)&#x60;
   *
   * Alternatively, it can be a partition name string.
   * @param {Object} [queryOptions] Options which are passed directly
   *                                through to &#x60;Meteor.users.find(query, options)&#x60;
   * @return {Cursor} Cursor of users in roles.
   * @static
   */
  getUsersInRole: function (roles, options, queryOptions) {
    var query;

    options = options || {};

    // ensure array to simplify code
    if (!_.isArray(roles)) roles = [roles];

    if (_.isString(options)) {
      options = {partition: options};
    }

    options.partition = options.partition || null;

    Roles._checkPartitionName(options.partition);

    options = _.defaults(options, {
      queryOptions: queryOptions || {},
      anyPartition: false
    });

    if (options.anyPartition) {
      query = {
        &#x27;roles._id&#x27;: {$in: roles}
      };
    }
    else {
      query = {
        $or: [{
          roles: {
            $elemMatch: {
              _id: {$in: roles},
              partition: options.partition
            }
          }
        }, {
          roles: {
            $elemMatch: {
              _id: {$in: roles},
              partition: null
            }
          }
        }]
      };
    }

    return Meteor.users.find(query, options.queryOptions);
  },

  /**
   * Deprecated. Use &#x60;getPartitionsForUser&#x60; instead.
   *
   * @method getGroupsForUser
   * @static
   * @deprecated
   */
  getGroupsForUser: function (/*args*/) {
    if (!getGroupsForUserDeprecationWarning) {
      getGroupsForUserDeprecationWarning = true;
      console &amp;&amp; console.warn(&quot;getGroupsForUser has been deprecated. Use getPartitionsForUser instead.&quot;);
    }

    return Roles.getPartitionsForUser.apply(this, arguments);
  },

  /**
   * Retrieve users partitions, if any.
   *
   * @method getPartitionsForUser
   * @param {String|Object} user User ID or an actual user object.
   * @param {String} [roles] Name of roles to restrict partitions to.
   *
   * @return {Array} Array of user&#x27;s partitions, unsorted.
   * @static
   */
  getPartitionsForUser: function (user, roles) {
    var partitions;

    // ensure array to simplify code
    if (roles &amp;&amp; !_.isArray(roles)) roles = [roles];

    user = Roles._resolveUser(user);

    if (!user) return [];

    partitions = [];
    _.each(user.roles || [], function (userRole) {
      // == used on purpose.
      if (userRole.partition == null) return;
      if (roles &amp;&amp; !_.contains(roles, userRole._id)) return;

      partitions.push(userRole.partition);
    });

    return _.uniq(partitions);
  },

  /**
   * Resolves the user ID into an actual user object with &#x60;roles&#x60; field,
   * if it is not already.
   *
   * @method _resolveUser
   * @param {String|Object} user User ID or an actual user object.
   * @param {Boolean} force Load a new user object even if it is already one.
   * @return {Object} User object.
   * @private
   * @static
   */
  _resolveUser: function (user, force) {
    // TODO: We could use $elemMatch to limit returned fields here.
    if (!_.isObject(user)) {
      user = Meteor.users.findOne(
               {_id: user},
               {fields: {roles: 1}});
    } else if (force || !_.has(user, &#x27;roles&#x27;)) {
      user = Meteor.users.findOne(
               {_id: user._id},
               {fields: {roles: 1}});
    }

    return user;
  },

  /**
   * @method _roleMatcher
   * @param {String} roleName A role name to match against.
   * @return {Function} A matcher function which accepts a role object and returns &#x60;true&#x60;
   *                     if its name matches &#x60;roleName&#x60;.
   * @private
   * @static
   */
  _roleMatcher: function (roleName) {
    return function (userRole) {
      return userRole._id === roleName;
    };
  },

  /**
   * @method _roleAndPartitionMatcher
   * @param {String} roleName A role name to match against.
   * @param {String} partition A partition to match against.
   * @return {Function} A matcher function which accepts a role object and returns &#x60;true&#x60;
   *                     if its name matches &#x60;roleName&#x60;, and partition matches &#x60;partition&#x60;.
   * @private
   * @static
   */
  _roleAndPartitionMatcher: function (roleName, partition) {
    return function (userRole) {
      // == used on purpose in &quot;userRole.partition == null&quot;
      return (userRole._id === roleName &amp;&amp; userRole.partition === partition) ||
        (userRole._id === roleName &amp;&amp; (!_.has(userRole, &#x27;partition&#x27;) || userRole.partition == null));
    };
  },

  /**
   * @method _partitionMatcher
   * @param {String} partition A partition to match against.
   * @return {Function} A matcher function which accepts a role object and returns &#x60;true&#x60;
   *                     if its partition matches &#x60;partition&#x60;.
   * @private
   * @static
   */
  _partitionMatcher: function (partition) {
    return function (userRole) {
      // == used on purpose in &quot;userRole.partition == null&quot;
      return (userRole.partition === partition) ||
        (!_.has(userRole, &#x27;partition&#x27;) || userRole.partition == null);
    };
  },

  /**
   * @method _onlyAssignedMatcher
   * @return {Function} A matcher function which accepts a role object and returns &#x60;true&#x60;
   *                     if the role is an assigned role.
   * @private
   * @static
   */
  _onlyAssignedMatcher: function () {
    return function (userRole) {
      return !!userRole.assigned;
    };
  },

  /**
   * Throw an exception if &#x60;roleName&#x60; is an invalid role name.
   *
   * @method _checkRoleName
   * @param {String} roleName A role name to match against.
   * @private
   * @static
   */
  _checkRoleName: function (roleName) {
    if (!roleName || !_.isString(roleName) || Roles._trim(roleName) !== roleName) {
      throw new Error(&quot;Invalid role name &#x27;&quot; + roleName + &quot;&#x27;.&quot;);
    }
  },

  /**
   * Throw an exception if &#x60;partitionName&#x60; is an invalid partition name.
   *
   * @method _checkRoleName
   * @param {String} partitionName A partition name to match against.
   * @private
   * @static
   */
  _checkPartitionName: function (partitionName) {
    if (partitionName === null) return;

    if (!partitionName || !_.isString(partitionName) || Roles._trim(partitionName) !== partitionName) {
      throw new Error(&quot;Invalid partition name &#x27;&quot; + partitionName + &quot;&#x27;.&quot;);
    }
  },

  /**
   * @param {String} string Input string.
   * @return {String} Trimmed string.
   * @private
   * @static
   */
  _trim: function (string) {
    if (string.trim) {
      return string.trim();
    }
    else {
      return string.replace(/^\s+|\s+$/g, &#x27;&#x27;);
    }
  }

});  // end _.extend(Roles ...)

}());

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
